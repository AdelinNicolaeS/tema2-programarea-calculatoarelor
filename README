Citim n de la tastatura, dupa care, in timp ce citim si memoram numarul de elemente de pe fiecare linie, citim elementele matricei a ce a fost alocată dinamic. Folosim funcția media_a care returnează media aritmetica a octetilor aflați la marginea matricei. Astfel, pentru calcularea mediei vom avea nevoie de toți octeții de pe prima si ultima linie, dupa care vom lua octeții de pe marginea celorlalte linii. Pentru rezolvarea taskului 2, citim in continuare k transformări ce vor avea loc asupra matricei. In cazul in care vom efectua transformarea "Modify", vom mai citi in continuare o variabila ce va reprezenta valoarea ce urmează sa fie implementata in matrice, tratând de asemenea si cazul in care poziția pe care dorim sa scriem aceasta valoare nu este valida, caz in care realocam linia, iar valorile noi, neinițializate vor deveni 0. In cazul operațiilor "Delete" si "Swap", apelam subprogramul sterg_schimb, care pentru ștergere va zeroiza blocul de date cerut, in timp ce operația de interschimbare a octetilor va avea loc cu ajutorul unor variabile auxiliare. La finalul acestei cerințe, vom afișa matricea modificata. Pentru ultima cerință, vom crea o matrice b care va memora pe fiecare linie octeții corespunzători liniilor din matricea a, precum si o matrice vizitat, cu valorile 0 sau 1, marcând daca poziția respectiva a fost sau nu parcursa. Vom construi o funcție recursiva de parcurgere a matricei b, care, pornind dintr-un punct oarecare, va numara cea mai lunga componenta de lungime 0, plecând spre fiecare vecin, verificand daca acesta este sau nu vizitat si daca valoarea de pe poziția corespunzătoare din b este 0, concatenand si repetand acest procedeu pentru noul punct-pivot. La final, vom parcurge matricea b cu funcția de mai sus, vom cauta noul maxim de lungime si vom păstra pivotul de coeficienti minimi din matrice, pe care ii vom afișa. Odata cerințele finalizate, vom elibera memoria din matricele si vectorii alocați dinamic.
